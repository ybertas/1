<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarih Bulmacası</title>
    <!-- Tailwind CSS CDN'i -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Inter fontunu kullan */
        html, body {
            height: 100%; /* Ensure html and body take full height */
            margin: 0;
            padding: 0;
            overflow-x: hidden; /* Prevent horizontal scroll on body */
            overflow-y: auto; /* Allow vertical scroll on body */
        }
        body {
            font-family: "Inter", sans-serif;
            background-color: #f0f4f8; /* Hafif gri arka plan */
            display: flex;
            flex-direction: column; /* Banner için dikey düzen */
            justify-content: flex-start; /* Banner'ı üste hizala */
            align-items: center;
            min-height: 100vh;
            padding: 1rem; /* Default padding */
            /* Tarihi arka plan görseli */
            background-image: url('https://www.shutterstock.com/shutterstock/photos/2501751711/display_1500/stock-vector-school-doodles-on-notebook-sheet-back-to-school-school-supplies-and-elements-are-drawn-on-a-2501751711.jpg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed; /* Arka planın sabit kalmasını sağlar */
        }

        /* Mobile specific body padding */
        @media (max-width: 767px) {
            body {
                padding: 0.5rem; /* Reduced padding on small screens */
            }
        }

        /* --------- EĞLENCELİ VE RENKLİ OYUN DOKUNUŞLARI --------- */

        /* Banner'ı gradientli ve hareketli yap */
        .banner {
            background: linear-gradient(90deg, #0284c7 60%, #38bdf8 100%);
            color: #fff;
            letter-spacing: 0.17em;
            text-shadow: 2px 2px 12px #0284c777;
            border-bottom: 4px solid #38bdf8;
            animation: bannerWave 3s infinite alternate;
            width: 100%;
            padding: 1rem 0;
            font-size: 2.5rem; /* Default font size */
            font-weight: bold;
            border-bottom-left-radius: 1rem;
            border-bottom-right-radius: 1rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            margin-bottom: 2rem;
            flex-shrink: 0;
            text-align: center;
        }
        @keyframes bannerWave {
            0% { filter: brightness(1); }
            100% { filter: brightness(1.07); }
        }

        /* Mobile specific banner font size */
        @media (max-width: 767px) {
            .banner {
                font-size: 1.4rem; /* Smaller font size on mobile */
                padding: 0.75rem 0; /* Slightly reduced padding */
                margin-bottom: 1rem; /* Reduced margin */
            }
        }

        .crossword-container {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 1.5rem; /* Default padding */
            display: flex;
            flex-direction: column; /* Mobile default: column */
            gap: 1.5rem; /* Default gap */
            max-width: 1024px;
            width: 100%;
            /* overflow-y: visible; removed from here, will be managed by body or grid itself */
            flex-grow: 1;
        }

        /* Mobile specific crossword-container padding and gap */
        @media (max-width: 767px) {
            .crossword-container {
                padding: 0.75rem; /* Reduced padding on small screens */
                gap: 1rem; /* Reduced gap */
            }
        }

        /* Masaüstü için yatay düzen */
        @media (min-width: 768px) {
            .crossword-container {
                flex-direction: row; /* Desktop: row */
                justify-content: center;
                align-items: flex-start;
                gap: 2rem; /* Default desktop gap */
                height: auto;
                overflow-y: visible;
            }
            .main-content-area {
                display: flex;
                flex-direction: column;
                gap: 1.5rem;
                width: 50%;
                max-width: 600px;
            }
            .questions-section {
                width: 50%;
            }
        }

        /* Mobile specific main-content-area and questions-section widths and gaps */
        @media (max-width: 767px) {
            .main-content-area,
            .questions-section {
                width: 100%; /* Full width on mobile */
                gap: 1rem; /* Reduced gap */
            }
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(12, minmax(0, 1fr));
            grid-template-rows: repeat(12, minmax(0, 1fr));
            border: 1px solid #cbd5e0;
            width: 100%;
            aspect-ratio: 1 / 1; /* Keep square ratio */
            max-width: 100%; /* Ensure it doesn't exceed its parent */
            overflow: hidden; /* Default to hidden, manage scroll with media query */
        }

        /* Mobile specific grid adjustments */
        @media (max-width: 767px) {
            .grid-container {
                max-width: 90vw; /* Max 90% of viewport width */
                min-height: 300px; /* Minimum height to prevent squishing */
                overflow: auto; /* Enable scrolling if content overflows */
                -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            }
        }

        .grid-cell {
            width: 100%;
            height: 100%;
            border: 1px solid #e2e8f0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9rem; /* Default font size */
            font-weight: bold;
            text-transform: uppercase;
            color: #334155;
            position: relative;
            background-color: #ffffff;
        }

        /* Mobile specific grid cell font size */
        @media (max-width: 767px) {
            .grid-cell {
                font-size: 0.85rem; /* Smaller font size on mobile */
            }
        }

        .grid-cell.black {
            background-color: #2d3748;
            pointer-events: none;
        }
        .grid-cell:not(.black):hover {
            background: linear-gradient(135deg, #e0f2fe 10%, #fef9c3 100%);
            box-shadow: 0 0 12px 2px #bae6fd99;
            z-index: 2;
            transition: background 0.3s, box-shadow 0.2s;
        }
        .grid-cell.highlighted {
            background-color: #bfdbfe;
        }
        .grid-cell.active {
            background-color: #60a5fa;
            color: #ffffff;
            animation: cellPop 0.3s;
            box-shadow: 0 0 8px 3px #38bdf866;
        }
        @keyframes cellPop {
            0% { transform: scale(1);}
            45% { transform: scale(1.14);}
            100% { transform: scale(1);}
        }

        .cell-number {
            position: absolute;
            top: 2px;
            left: 2px;
            font-size: 0.6rem;
            font-weight: normal;
            color: #475569;
        }
        .questions-section {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .question-group {
            background-color: #f8fafc;
            border-radius: 0.75rem;
            padding: 1rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            border: 2px solid #bae6fd;
            transition: border-color 0.3s, transform 0.15s;
        }
        .question-group:hover {
            border-color: #fbbf24;
            transform: translateY(-2px) scale(1.01);
        }
        .question-group h3 {
            font-size: 1.1rem;
            font-weight: bold;
            margin-bottom: 0.75rem;
            color: #1e293b;
        }
        .question-item {
            cursor: pointer;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            transition: background 0.19s, color 0.17s, transform 0.13s;
            color: #475569;
        }
        .question-item:hover,
        .question-item.active-question {
            background: linear-gradient(90deg, #bae6fd 50%, #fbbf24 100%);
            color: #0c4a6e;
            transform: scale(1.06);
            box-shadow: 0 2px 8px #bae6fd33;
        }
        input[type="text"] {
            width: 100%;
            height: 100%;
            text-align: center;
            border: none;
            background: transparent;
            outline: none;
            font-size: 0.9rem; /* Default input font size */
            font-weight: bold;
            text-transform: uppercase;
            color: #334155;
            padding: 0;
            margin: 0;
            box-sizing: border-box;
        }

        /* Mobile specific input font size */
        @media (max-width: 767px) {
            input[type="text"] {
                font-size: 0.85rem; /* Smaller input font size on mobile */
            }
        }

        /* Doğru ve yanlış harfler için animasyon ve renk */
        input.correct-letter {
            background: #bbf7d0 !important;
            color: #166534;
            animation: popGreen 0.21s;
        }
        input.incorrect-letter {
            background: #fecaca !important;
            color: #b91c1c;
            animation: shakeRed 0.17s;
        }
        @keyframes popGreen {
            0% { transform: scale(0.98);}
            55% { transform: scale(1.1);}
            100% { transform: scale(1);}
        }
        @keyframes shakeRed {
            0%,100% { transform: translateX(0);}
            35% { transform: translateX(-2px);}
            60% { transform: translateX(2px);}
            80% { transform: translateX(-1px);}
        }

        /* Modal arkaplanı okuması kolay ve yumuşak */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #e0f2fecc, #f1f5f9ee 60%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        /* Modal açılış animasyonu */
        .modal-content {
            background-color: #ffffff;
            padding: 2rem; /* Default padding */
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            text-align: center;
            position: relative;
            animation: modalOpen 0.35s cubic-bezier(.3,1.8,.58,1.04);
        }

        /* Mobile specific modal padding */
        @media (max-width: 767px) {
            .modal-content {
                padding: 1.25rem; /* Reduced padding on mobile */
            }
            .modal-content h2 {
                font-size: 1.3rem; /* Slightly smaller modal title */
            }
            .modal-content ul li {
                font-size: 0.9rem; /* Slightly smaller modal text */
            }
        }

        @keyframes modalOpen {
            0% { opacity: 0; transform: scale(0.85);}
            100% { opacity: 1; transform: scale(1);}
        }
        .modal-content h2 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 1rem;
            color: #1e293b;
        }
        .modal-content ul {
            list-style: none;
            padding: 0;
            margin-bottom: 1.5rem;
            text-align: left;
        }
        .modal-content ul li {
            margin-bottom: 0.75rem;
            color: #475569;
            font-size: 0.95rem;
        }
        .modal-content ul li strong {
            color: #1e293b;
        }
        .modal-close-button {
            background-color: #3b82f6;
            color: #ffffff;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .modal-close-button:hover {
            background-color: #2563eb;
            transform: translateY(-1px);
        }
        .modal-close-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        /* Kronometre ve Butonlar için yeni düzen */
        .timer-section {
            background-color: #e0e7ff;
            padding: 0.3rem 0.8rem;
            border-radius: 0.6rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.4rem;
            margin-bottom: 0.3rem;
            width: fit-content;
            align-self: center;
            animation: pulse 1.5s infinite alternate;
        }
        .timer-section .text-2xl {
            font-size: 1.2rem;
            color: #334155;
        }
        /* Butonlara gradientli ve zıplamalı efektler */
        .buttons-section {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }
        .buttons-section button {
            padding: 0.6rem 1.2rem; /* Default button padding */
            font-size: 0.9rem; /* Default button font size */
            font-weight: 700;
            transition: transform 0.16s, background 0.19s;
            border-radius: 0.75rem;
        }

        /* Mobile specific button sizes */
        @media (max-width: 767px) {
            .buttons-section button {
                padding: 0.5rem 1rem; /* Reduced padding on mobile */
                font-size: 0.8rem; /* Smaller font size on mobile */
            }
        }

        #reset-button {
            background: linear-gradient(90deg, #fbbf24, #f59e42 60%);
            color: #fff;
            box-shadow: 0 2px 10px #fde68a66;
            border: none;
        }
        #reset-button:hover {
            background: linear-gradient(90deg, #f59e42, #fbbf24 60%);
            transform: scale(1.08) rotate(-2deg);
        }
        #show-answers-button {
            background: linear-gradient(90deg, #ef4444, #f87171 60%);
            color: #fff;
            box-shadow: 0 2px 10px #fecaca88;
            border: none;
        }
        #show-answers-button:hover {
            background: linear-gradient(90deg, #f87171, #ef4444 60%);
            transform: scale(1.08) rotate(2deg);
        }
        #how-to-play-button {
            background: linear-gradient(90deg, #0284c7, #38bdf8 60%);
            color: #fff;
            box-shadow: 0 2px 10px #bae6fd99;
            border: none;
        }
        #how-to-play-button:hover {
            background: linear-gradient(90deg, #38bdf8, #0284c7 60%);
            transform: scale(1.08) rotate(-1deg);
        }

        /* Yeni Tebrik Modalı Stilleri */
        #success-modal .modal-content {
            background: #e0f2fe;
            border: 2px solid #38bdf8;
            animation: bounceSuccess 0.4s;
        }
        @keyframes bounceSuccess {
            0% { transform: scale(0.7);}
            40% { transform: scale(1.09);}
            100% { transform: scale(1);}
        }
        #success-modal h2 {
            color: #0284c7;
        }
        #success-modal p {
            color: #0ea5e9;
        }
        #success-modal .final-time {
            color: #10b981;
        }
        #success-modal .play-again-button {
            background: linear-gradient(90deg, #22d3ee, #38bdf8);
            color: #fff;
            border: none;
        }
        #success-modal .play-again-button:hover {
            background: linear-gradient(90deg, #38bdf8, #22d3ee);
            transform: scale(1.08) rotate(-2deg);
        }

        /* Timer için nabız atışı animasyonu */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <!-- Konfeti efekt alanı -->
    <canvas id="confetti-canvas" style="position:fixed; left:0; top:0; width:100vw; height:100vh; pointer-events:none; z-index:9999; display:none;"></canvas>

    <!-- Yeni Banner -->
    <div class="banner">
        ÇENGEL BULMACA
    </div>

    <div class="crossword-container">
        <!-- Ana İçerik Alanı: Izgara ve Kontroller -->
        <div class="main-content-area">
            <!-- Oyun Kontrolleri ve Zamanlayıcı -->
            <div class="timer-section">
                <div class="text-2xl font-bold text-gray-700">
                    Süre: <span id="timer-display">00:00</span>
                </div>
            </div>

            <div class="grid-container" id="crossword-grid">
                <!-- Izgara hücreleri JavaScript tarafından doldurulacak -->
            </div>

            <div class="buttons-section">
                <button id="reset-button" class="bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-200">
                    🔄 Sıfırla
                </button>
                <button id="show-answers-button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-200">
                    👀 Cevapları Göster
                </button>
                <button id="how-to-play-button" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition-all duration-200">
                    ❓ Nasıl Oynanır?
                </button>
            </div>
        </div>

        <!-- Sorular Bölümü -->
        <div class="questions-section">
            <div class="question-group">
                <h3 class="text-blue-600">🟦 Yatay Sorular ve Cevaplar</h3>
                <ul id="horizontal-questions">
                    <!-- Yatay sorular JavaScript tarafından doldurulacak -->
                </ul>
            </div>
            <div class="question-group mt-4">
                <h3 class="text-green-600">🟩 Dikey Sorular ve Cevaplar</h3>
                <ul id="vertical-questions">
                    <!-- Dikey sorular JavaScript tarafından doldurulacak -->
                </ul>
            </div>
        </div>
    </div>

    <!-- Giriş Modalı Yapısı -->
    <div id="intro-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2>BULMACAYI NASIL OYNARSIN?</h2>
            <ul>
                <li><strong>📖 1. Soruları Oku</strong><br>Yatay ve dikey soruları dikkatlice incele.</li>
                <li><strong>✏️ 2. Cevapları Yaz</strong><br>Bulduğun cevapları ilgili bulmaca kutucuklarına yaz. Soruların üstüne tıklayarak ilgili kelimeyi aktif edebilirsin.</li>
                <li><strong>✅ 3. Cevaplarını Kontrol Et</strong><br>Cevabın doğruysa harfler yeşil, yanlışsa kırmızı yanacak.</li>
                <li><strong>🔄 4. “Sıfırla” Butonunu Kullan</strong><br>Yanlış yaptıysan üzülme! Bu butonla oyuna en baştan başlayabilirsin.</li>
                <li><strong>👀 5. “Cevapları Göster” Butonu</strong><br>Tüm doğru cevapları görmek için bu butona tıklayabilirsin.</li>
            </ul>
            <button id="close-modal-button" class="modal-close-button">Hadi Başlayalım!</button>
        </div>
    </div>

    <!-- Başarı Modalı Yapısı -->
    <div id="success-modal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2>Tebrikler! 🎉</h2>
            <p>Bulmacayı başarıyla tamamladınız!</p>
            <p class="final-time">Süreniz: <span id="final-time-display">00:00</span></p>
            <button id="play-again-button" class="play-again-button">Tekrar Oyna</button>
        </div>
    </div>

    <!-- Başarı Müziği -->
    <audio id="success-sound" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" preload="auto"></audio>
    <!-- Not: Güvenlik nedeniyle doğrudan ses dosyası yükleyemiyorum. Kendi ses dosyanızın URL'sini buraya ekleyebilirsiniz. Örneğin: <audio id="success-sound" src="sesler/basari.mp3" preload="auto"></audio> -->


    <script>
        // --- SCORM 1.2 API Mock (for demonstration purposes in this environment) ---
        // In a real SCORM LMS, this mock would be replaced by the LMS's actual API.
        let scormInitialized = false;
        let scormData = {};

        function LMSInitialize(param) {
            console.log("SCORM: LMSInitialize called with", param);
            scormInitialized = true;
            // In a real LMS, this would load cmi data
            scormData = {
                'cmi.core.lesson_status': 'not attempted',
                'cmi.core.score.raw': 0,
                'cmi.core.total_time': 'PT0H0M0S' // SCORM 1.2 time format
            };
            return "true";
        }

        function LMSGetValue(param) {
            console.log("SCORM: LMSGetValue called for", param);
            return scormData[param] || "";
        }

        function LMSSetValue(param, value) {
            console.log(`SCORM: LMSSetValue called for ${param} with value ${value}`);
            scormData[param] = value;
            return "true";
        }

        function LMSCommit(param) {
            console.log("SCORM: LMSCommit called with", param);
            // In a real LMS, this would save data
            return "true";
        }

        function LMSFinish(param) {
            console.log("SCORM: LMSFinish called with", param);
            scormInitialized = false;
            return "true";
        }

        // Global API object (as SCORM expects to find it in the parent window)
        // For this environment, we'll make it available directly on window.
        window.API = {
            LMSInitialize: LMSInitialize,
            LMSGetValue: LMSGetValue,
            LMSSetValue: LMSSetValue,
            LMSCommit: LMSCommit,
            LMSFinish: LMSFinish
        };
        // Some SCORM wrappers use findAPI or getAPI
        window.findAPI = function() { return window.API; };
        window.getAPI = function() { return window.API; };
        // --- End SCORM API Mock ---


        // Bulmaca yapısı ve cevaplar
        const crosswordData = {
            gridSize: 12, // Izgara boyutu (12x12 olarak güncellendi)
            words: [
                {
                    word: "DİVAN", // Updated to Turkish I
                    clue: "Osmanlı’da devlet işlerinin görüşüldüğü kurulun adı nedir?",
                    start_x: 0, // Row 0
                    start_y: 0, // Col 0
                    direction: "across",
                    number: 1 // Yatay 1
                },
                {
                    word: "SALTUK",
                    clue: "Anadolu’da kurulan ilk Türk beyliklerinden biri hangisidir?",
                    start_x: 6, // Row 6
                    start_y: 5, // Col 5 (S at (6,5) intersects SAHN, A at (6,6) intersects KONYA, U at (6,9) intersects BURSA)
                    direction: "across",
                    number: 2 // Yatay 2
                },
                {
                    word: "PAŞA", // Updated to Turkish S with cedilla
                    clue: "Osmanlı’da yüksek rütbeli askerî komutanlara verilen unvan nedir?",
                    start_x: 9, // Row 9
                    start_y: 8, // Col 8 (A at (9,9) intersects BURSA)
                    direction: "across",
                    number: 3 // Yatay 3
                },
                {
                    word: "SELANİK", // Updated to Turkish I
                    clue: "Atatürk’ün doğduğu şehir hangisidir?",
                    start_x: 2, // Row 2
                    start_y: 0, // Col 0 (A at (2,3) intersects ATATÜRK, K at (2,6) intersects KONYA)
                    direction: "across",
                    number: 4 // Yatay 4
                },
                {
                    word: "ATATÜRK", // Updated to Turkish U with umlaut and I
                    clue: "Türkiye Cumhuriyeti’nin kurucusunun soyadı nedir?",
                    start_x: 0, // Row 0
                    start_y: 3, // Col 3 (A at (0,3) intersects DİVAN, A at (2,3) intersects SELANİK)
                    direction: "down",
                    number: 5 // Dikey 1
                },
                {
                    word: "BURSA",
                    clue: "Osmanlı Devleti’nin ilk başkenti neresidir?",
                    start_x: 5, // Row 5
                    start_y: 9, // Col 9 (U at (6,9) intersects SALTUK, A at (9,9) intersects PAŞA)
                    direction: "down",
                    number: 6 // Dikey 2
                },
                {
                    word: "SAHN",
                    clue: "Osmanlı’da eğitim verilen medrese türü nedir?",
                    start_x: 6, // Row 6
                    start_y: 5, // Col 5 (S at (6,5) intersects SALTUK)
                    direction: "down",
                    number: 7 // Dikey 3
                },
                {
                    word: "KONYA",
                    clue: "Anadolu Selçuklu Devleti’nin başkenti neresidir?",
                    start_x: 2, // Row 2
                    start_y: 6, // Col 6 (K at (2,6) intersects SELANİK, A at (6,6) intersects SALTUK)
                    direction: "down",
                    number: 8 // Dikey 4
                }
            ],
            blackCells: [] // Bu kısım JavaScript tarafından dinamik olarak doldurulacak
        };

        const gridContainer = document.getElementById('crossword-grid');
        const horizontalQuestionsList = document.getElementById('horizontal-questions');
        const verticalQuestionsList = document.getElementById('vertical-questions');
        const timerDisplay = document.getElementById('timer-display');
        const resetButton = document.getElementById('reset-button');
        const showAnswersButton = document.getElementById('show-answers-button');
        // Corrected the assignment here:
        const howToPlayButton = document.getElementById('how-to-play-button');
        const introModal = document.getElementById('intro-modal');
        const closeModalButton = document.getElementById('close-modal-button');
        const successModal = document.getElementById('success-modal'); // Yeni başarı modalı
        const finalTimeDisplay = document.getElementById('final-time-display'); // Başarı modalındaki süre göstergesi
        const playAgainButton = document.getElementById('play-again-button'); // Başarı modalındaki tekrar oyna butonu
        const successSound = document.getElementById('success-sound'); // Başarı müziği

        let activeCells = []; // Şu anda vurgulanan hücreler
        let activeQuestionElement = null; // Şu anda aktif olan soru elementi
        let activeDirection = null; // Şu anda aktif olan yazma yönü ('across' veya 'down')
        let lastFocusedCell = null; // Son odaklanılan hücre (toggle için)

        let timerInterval = null;
        let seconds = 0;
        let isPuzzleSolved = false; // Bulmacanın çözülüp çözülmediğini takip eder

        // Zamanlayıcıyı güncelle
        function updateTimerDisplay() {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
        }

        // Zamanlayıcıyı başlat
        function startTimer() {
            if (timerInterval) clearInterval(timerInterval); // Önceki zamanlayıcıyı temizle
            timerInterval = setInterval(() => {
                seconds++;
                updateTimerDisplay();
            }, 1000);
        }

        // Zamanlayıcıyı durdur
        function stopTimer() {
            clearInterval(timerInterval);
            timerInterval = null;
        }

        // Bulmacayı sıfırla
        function resetPuzzle() {
            stopTimer();
            seconds = 0;
            updateTimerDisplay();
            isPuzzleSolved = false;

            // Tüm giriş kutularını temizle ve stil sınıflarını kaldır
            document.querySelectorAll('.grid-cell input').forEach(input => {
                input.value = '';
                input.classList.remove('correct-letter', 'incorrect-letter');
            });

            // Vurguları kaldır
            activeCells.forEach(cell => cell.classList.remove('highlighted', 'active'));
            activeCells = [];
            if (activeQuestionElement) {
                activeQuestionElement.classList.remove('active-question');
                activeQuestionElement = null;
            }
            activeDirection = null;
            lastFocusedCell = null;

            hideSuccessModal(); // Başarı modalını gizle
            startTimer(); // Zamanlayıcıyı tekrar başlat
        }

        // Tüm cevapları göster
        function showAnswers() {
            stopTimer();
            isPuzzleSolved = true; // Cevaplar gösterildiği için bulmaca çözüldü sayılır

            crosswordData.words.forEach(wordData => {
                let currentX = wordData.start_x;
                let currentY = wordData.start_y;
                for (let i = 0; i < wordData.word.length; i++) {
                    const cell = gridContainer.querySelector(`[data-row="${currentX}"][data-col="${currentY}"]`);
                    if (cell && !cell.classList.contains('black')) {
                        const input = cell.querySelector('input');
                        input.value = wordData.word[i];
                        input.classList.remove('incorrect-letter'); // Yanlış stilini kaldır
                        input.classList.add('correct-letter'); // Doğru stilini ekle
                    }
                    if (wordData.direction === "across") {
                        currentY++;
                    } else {
                        currentX++;
                    }
                }
            });
        }

        // Izgarayı oluştur ve siyah hücreleri belirle
        function createGrid() {
            const tempGrid = Array(crosswordData.gridSize).fill(null).map(() => Array(crosswordData.gridSize).fill(0)); // 0 for empty, 1 for word cell

            // Kelimelerin kapladığı hücreleri işaretle
            crosswordData.words.forEach(wordData => {
                let currentX = wordData.start_x;
                let currentY = wordData.start_y;
                for (let i = 0; i < wordData.word.length; i++) {
                    if (currentX < crosswordData.gridSize && currentY < crosswordData.gridSize) {
                        tempGrid[currentX][currentY] = 1;
                    }
                    if (wordData.direction === "across") {
                        currentY++;
                    } else {
                        currentX++;
                    }
                }
            });

            // Siyah hücreleri topla
            const calculatedBlackCells = [];
            for (let i = 0; i < crosswordData.gridSize; i++) {
                for (let j = 0; j < crosswordData.gridSize; j++) {
                    if (tempGrid[i][j] === 0) {
                        calculatedBlackCells.push({ x: i, y: j });
                    }
                }
            }
            crosswordData.blackCells = calculatedBlackCells; // blackCells verisini güncelle

            // Izgara hücrelerini oluştur
            for (let i = 0; i < crosswordData.gridSize; i++) {
                for (let j = 0; j < crosswordData.gridSize; j++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.dataset.row = i;
                    cell.dataset.col = j;

                    // Siyah hücreleri işaretle
                    const isBlackCell = crosswordData.blackCells.some(bc => bc.x === i && bc.y === j);
                    if (isBlackCell) {
                        cell.classList.add('black');
                    } else {
                        // Giriş kutusu ekle
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.maxLength = 1; // Tek karakter girişi
                        input.addEventListener('input', handleCellInput);
                        input.addEventListener('focus', handleCellFocus);
                        cell.appendChild(input);
                    }
                    gridContainer.appendChild(cell);
                }
            }
        }

        // Soru numaralarını yerleştir
        function populateWords() {
            crosswordData.words.forEach(wordData => {
                let currentX = wordData.start_x;
                let currentY = wordData.start_y;

                // Soru numarasını yerleştir
                const cell = gridContainer.querySelector(`[data-row="${currentX}"][data-col="${currentY}"]`);
                if (cell && !cell.querySelector('.cell-number')) {
                    const numberSpan = document.createElement('span');
                    numberSpan.classList.add('cell-number');
                    numberSpan.textContent = wordData.number;
                    cell.appendChild(numberSpan);
                }

                // Her harf için hücreleri işaretle (bu kısım zaten createGrid içinde yapılıyor, ancak dataset'leri burada ayarlayabiliriz)
                for (let i = 0; i < wordData.word.length; i++) {
                    const cellToMark = gridContainer.querySelector(`[data-row="${currentX}"][data-col="${currentY}"]`);
                    if (cellToMark) {
                        cellToMark.dataset.wordNumber = wordData.number;
                        cellToMark.dataset.direction = wordData.direction;
                    }
                    if (wordData.direction === "across") {
                        currentY++;
                    } else {
                        currentX++;
                    }
                }
            });
        }

        // Soruları listele
        function listQuestions() {
            horizontalQuestionsList.innerHTML = ''; // Önceki listeyi temizle
            verticalQuestionsList.innerHTML = ''; // Önceki listeyi temizle

            // Yatay soruları filtrele ve listele
            crosswordData.words.filter(w => w.direction === "across").sort((a, b) => a.number - b.number).forEach(wordData => {
                const listItem = document.createElement('li');
                listItem.classList.add('question-item', 'rounded-lg');
                listItem.dataset.wordNumber = wordData.number;
                listItem.dataset.direction = wordData.direction;
                listItem.innerHTML = `<span class="font-bold">${wordData.number}.</span> ${wordData.clue}`;
                listItem.addEventListener('click', () => handleQuestionClick(wordData.number, wordData.direction, listItem));
                horizontalQuestionsList.appendChild(listItem);
            });

            // Dikey soruları filtrele ve listele
            crosswordData.words.filter(w => w.direction === "down").sort((a, b) => a.number - b.number).forEach(wordData => {
                const listItem = document.createElement('li');
                listItem.classList.add('question-item', 'rounded-lg');
                listItem.dataset.wordNumber = wordData.number;
                listItem.dataset.direction = wordData.direction;
                listItem.innerHTML = `<span class="font-bold">${wordData.number}.</span> ${wordData.clue}`;
                listItem.addEventListener('click', () => handleQuestionClick(wordData.number, wordData.direction, listItem));
                verticalQuestionsList.appendChild(listItem);
            });
        }

        // Hücreleri vurgula
        function highlightCells(wordNumber, direction, cellToFocus = null) { // Added cellToFocus parameter
            // Önceki vurguları kaldır
            activeCells.forEach(cell => cell.classList.remove('highlighted', 'active'));
            activeCells = [];

            // İlgili kelimeyi bul
            const wordData = crosswordData.words.find(w => w.number === wordNumber && w.direction === direction);

            if (wordData) {
                let currentX = wordData.start_x;
                let currentY = wordData.start_y;

                for (let i = 0; i < wordData.word.length; i++) {
                    const cell = gridContainer.querySelector(`[data-row="${currentX}"][data-col="${currentY}"]`);
                    if (cell && !cell.classList.contains('black')) {
                        cell.classList.add('highlighted');
                        activeCells.push(cell);
                    }
                    if (direction === "across") {
                        currentY++;
                    } else {
                        currentX++;
                    }
                }

                let targetCell = cellToFocus;
                if (!targetCell || activeCells.indexOf(targetCell) === -1) {
                    // If no specific cell to focus, or it's not part of the current word, find the first empty or first cell
                    targetCell = activeCells.find(cell => {
                        const input = cell.querySelector('input');
                        return input && input.value === '';
                    });
                    if (!targetCell && activeCells.length > 0) {
                        targetCell = activeCells[0];
                    }
                }

                if (targetCell) {
                    targetCell.classList.add('active');
                    targetCell.querySelector('input').focus();
                }
            }
        }

        // Soruya tıklandığında
        function handleQuestionClick(wordNumber, direction, clickedQuestionElement, cellToFocusFromClick = null) { // Added cellToFocusFromClick
            // Önceki aktif soruyu kaldır
            if (activeQuestionElement) {
                activeQuestionElement.classList.remove('active-question');
            }
            // Yeni aktif soruyu ayarla
            activeQuestionElement = clickedQuestionElement;
            activeQuestionElement.classList.add('active-question');
            activeDirection = direction; // Aktif yönü ayarla

            highlightCells(wordNumber, direction, cellToFocusFromClick); // Pass it along
        }

        // Hücreye odaklanıldığında
        function handleCellFocus(event) {
            const input = event.target; // The input element that received focus
            const cell = input.closest('.grid-cell');
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);

            // Select the content of the input field
            input.select(); // This is the key change for easier overwriting

            // Önceki vurguları kaldır
            activeCells.forEach(c => c.classList.remove('highlighted', 'active'));
            activeCells = [];

            // Hücrenin ait olduğu kelimeleri bul
            const relevantWords = crosswordData.words.filter(wordData => {
                let currentX = wordData.start_x;
                let currentY = wordData.start_y;
                for (let i = 0; i < wordData.word.length; i++) {
                    if (currentX === row && currentY === col) {
                        return true;
                    }
                    if (wordData.direction === "across") {
                        currentY++;
                    } else {
                        currentX++;
                    }
                }
                return false;
            });

            if (relevantWords.length === 0) return; // Siyah hücreye odaklanma durumunda

            let selectedWord = null;

            if (relevantWords.length === 1) {
                // Sadece bir kelimeye aitse, o kelimeyi seç
                selectedWord = relevantWords[0];
                activeDirection = selectedWord.direction; // Yönü ayarla
            } else { // Kesişen hücre
                if (lastFocusedCell === cell) {
                    // Aynı hücreye tekrar tıklanırsa yönu değiştir
                    if (activeDirection === 'across') {
                        selectedWord = relevantWords.find(w => w.direction === 'down');
                        if (selectedWord) activeDirection = 'down';
                        else selectedWord = relevantWords.find(w => w.direction === 'across'); // Fallback: Eğer dikey yoksa yatayı tekrar seç
                    } else {
                        selectedWord = relevantWords.find(w => w.direction === 'across');
                        if (selectedWord) activeDirection = 'across';
                        else selectedWord = relevantWords.find(w => w.direction === 'down'); // Fallback: Eğer yatay yoksa dikey'i tekrar seç
                    }
                } else {
                    // İlk tıklamada veya farklı bir hücreye tıklamada, mevcut yöne öncelik ver
                    selectedWord = relevantWords.find(w => w.direction === activeDirection);
                    if (!selectedWord) { // Mevcut yön bu hücre için geçerli değilse veya null ise
                        selectedWord = relevantWords.find(w => w.direction === 'across') || relevantWords[0]; // Yatayı tercih et veya ilk bulunanı al
                        activeDirection = selectedWord.direction;
                    }
                }
            }

            lastFocusedCell = cell; // Son odaklanılan hücreyi güncelle

            if (selectedWord) {
                handleQuestionClick(selectedWord.number, selectedWord.direction,
                    document.querySelector(`.question-item[data-word-number="${selectedWord.number}"][data-direction="${selectedWord.direction}"]`),
                    cell // Pass the cell that was just focused
                );
            }
        }

        // Kelimenin tamamlandığını ve doğruluğunu kontrol et
        function checkActiveWordCompletion() {
            if (!activeQuestionElement) return; // Aktif bir soru yoksa kontrol etme

            const wordNumber = parseInt(activeQuestionElement.dataset.wordNumber);
            const direction = activeQuestionElement.dataset.direction;

            const wordData = crosswordData.words.find(w => w.number === wordNumber && w.direction === direction);
            if (!wordData) return;

            let userAnswer = '';
            const cellsOfWord = [];
            let currentX = wordData.start_x;
            let currentY = wordData.start_y;

            for (let i = 0; i < wordData.word.length; i++) {
                const cell = gridContainer.querySelector(`[data-row="${currentX}"][data-col="${currentY}"]`);
                if (cell && !cell.classList.contains('black')) {
                    const input = cell.querySelector('input');
                    userAnswer += input.value || '';
                    cellsOfWord.push({ cell, input, correctLetter: wordData.word[i] });
                }
                if (direction === "across") {
                    currentY++;
                } else {
                    currentX++;
                }
            }

            // Önce tüm kelimenin hücrelerinden feedback sınıflarını kaldır
            cellsOfWord.forEach(({ input }) => {
                input.classList.remove('correct-letter', 'incorrect-letter');
            });

            if (userAnswer.length === wordData.word.length) { // Kelime tamamen doldurulduysa
                let isWordCorrect = true;
                cellsOfWord.forEach(({ cell, input, correctLetter }, index) => {
                    // Karşılaştırma yaparken de toLocaleUpperCase kullan
                    if (input.value.toLocaleUpperCase('tr-TR') === correctLetter) {
                        input.classList.add('correct-letter');
                    } else {
                        input.classList.add('incorrect-letter');
                        isWordCorrect = false; // Kelimenin tamamı doğru değil
                    }
                });
                // Tüm kelimelerin doğru olup olmadığını kontrol et
                checkAllWordsSolved();
            }
            // Eğer kelime tamamlanmadıysa (userAnswer.length < wordData.word.length),
            // feedback sınıfları zaten yukarıda kaldırıldığı için burada ek bir işlem yapmaya gerek yok.
        }

        // Tüm kelimelerin çözülüp çözülmediğini kontrol et
        function checkAllWordsSolved() {
            let allWordsCorrect = true;
            crosswordData.words.forEach(wordData => {
                let currentWordUserAnswer = '';
                let currentX = wordData.start_x;
                let currentY = wordData.start_y;
                for (let i = 0; i < wordData.word.length; i++) {
                    const cell = gridContainer.querySelector(`[data-row="${currentX}"][data-col="${currentY}"]`);
                    if (cell && !cell.classList.contains('black')) {
                        const input = cell.querySelector('input');
                        currentWordUserAnswer += input.value || '';
                    }
                    if (wordData.direction === "across") {
                        currentY++;
                    } else {
                        currentX++;
                    }
                }
                // Karşılaştırma yaparken de toLocaleUpperCase kullan
                if (currentWordUserAnswer.toLocaleUpperCase('tr-TR') !== wordData.word) {
                    allWordsCorrect = false;
                }
            });

            if (allWordsCorrect && !isPuzzleSolved) {
                stopTimer();
                isPuzzleSolved = true;
                showSuccessModal(); // Başarı modalını göster
                playSuccessSound(); // Başarı müziğini çal

                // SCORM: Set completion and score
                if (window.API && typeof window.API.LMSSetValue === 'function') {
                    window.API.LMSSetValue('cmi.core.lesson_status', 'completed');
                    window.API.LMSSetValue('cmi.core.score.raw', 100);
                    // Format time for SCORM 1.2 (PTnHnMnS)
                    const minutes = Math.floor(seconds / 60);
                    const remainingSeconds = seconds % 60;
                    const totalTime = `PT${minutes}M${remainingSeconds}S`;
                    window.API.LMSSetValue('cmi.core.total_time', totalTime);
                    window.API.LMSCommit('');
                } else {
                    console.warn("SCORM API not found or not initialized. Cannot send data to LMS.");
                }
            }
        }


        // Hücreye metin girildiğinde
        function handleCellInput(event) {
            const input = event.target;
            // Türkçe karakterleri doğru şekilde büyük harfe çevir
            const value = input.value.toLocaleUpperCase('tr-TR');
            input.value = value; // Büyük harfe çevir

            // Mevcut hücredeki feedback'i temizle (bu satır hala gerekli çünkü Backspace dışındaki input olaylarında da temizlik yapmalı)
            input.classList.remove('correct-letter', 'incorrect-letter');

            // Bir sonraki hücreye otomatik odaklanma
            const currentCell = input.closest('.grid-cell');
            const currentIndex = activeCells.indexOf(currentCell);

            if (currentIndex !== -1 && currentIndex < activeCells.length - 1) {
                const nextCell = activeCells[currentIndex + 1];
                const nextInput = nextCell.querySelector('input');
                if (nextInput) {
                    nextInput.focus();
                }
            }
            // Kelime tamamlandığında kontrol et
            checkActiveWordCompletion();
        }

        // Klavyeden girişleri dinle (geri tuşu, ok tuşları vb.)
        document.addEventListener('keydown', (event) => {
            const activeInput = document.activeElement;
            if (activeInput && activeInput.tagName === 'INPUT' && activeInput.closest('.grid-cell')) {
                const currentCell = activeInput.closest('.grid-cell');
                const currentIndex = activeCells.indexOf(currentCell);

                if (currentIndex === -1) return; // Aktif hücre vurgulanan bir kelimenin parçası değilse çık

                if (event.key === 'Backspace') {
                    if (activeInput.value !== '') {
                        activeInput.value = ''; // Karakteri sil
                        // Sadece mevcut hücrenin stilini temizle, checkActiveWordCompletion tüm kelimeyi halledecek
                        activeInput.classList.remove('correct-letter', 'incorrect-letter');
                    } else if (currentIndex > 0) {
                        // Eğer boşsa ve önceki hücre varsa, önceki hücreye git VE içeriğini sil
                        const prevCell = activeCells[currentIndex - 1];
                        const prevInput = prevCell.querySelector('input');
                        if (prevInput) {
                            prevInput.value = ''; // Önceki kutunun içeriğini sil
                            // Sadece önceki hücrenin stilini temizle
                            prevInput.classList.remove('correct-letter', 'incorrect-letter');
                            prevInput.focus();
                        }
                    }
                    event.preventDefault(); // Varsayılan geri tuşu davranışını engelle (sayfa geri gitmesini önler)
                    checkActiveWordCompletion(); // Silme sonrası kelime durumunu kontrol et
                } else if (event.key === 'ArrowLeft' || event.key === 'ArrowRight' || event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                    event.preventDefault(); // Varsayılan kaydırma davranışını engelle

                    let nextCell = null;
                    const currentRow = parseInt(currentCell.dataset.row);
                    const currentCol = parseInt(currentCell.dataset.col);

                    // Aktif yöne göre ilerleme
                    if (activeDirection === 'across') {
                        if (event.key === 'ArrowLeft') {
                            nextCell = gridContainer.querySelector(`[data-row="${currentRow}"][data-col="${col - 1}"]`);
                        } else if (event.key === 'ArrowRight') {
                            nextCell = gridContainer.querySelector(`[data-row="${currentRow}"][data-col="${col + 1}"]`);
                        }
                    } else if (activeDirection === 'down') {
                        if (event.key === 'ArrowUp') {
                            nextCell = gridContainer.querySelector(`[data-row="${currentRow - 1}"][data-col="${col}"]`);
                        } else if (event.key === 'ArrowDown') {
                            nextCell = gridContainer.querySelector(`[data-row="${currentRow + 1}"][data-col="${col}"]`);
                        }
                    }

                    // Eğer ok tuşuyla hareket edilen yer aktif kelimenin bir parçası değilse veya yön değiştirme isteği varsa
                    // (örneğin yatay kelime aktifken dikey ok tuşuna basılırsa),
                    // bu mantık daha karmaşık hale gelebilir. Şimdilik sadece aktif kelime içinde hareket sağlar.
                    if (!nextCell || nextCell.classList.contains('black') || activeCells.indexOf(nextCell) === -1) {
                         // Eğer ok tuşuyla hareket edilen hücre aktif kelimenin parçası değilse veya siyahsa,
                         // bu durumda genel ok tuşu davranışı yerine, aktif kelime içindeki sonraki/önceki hücreye gitmeyi deneyelim.
                         // Bu, kullanıcının aktif kelime içinde kalmasını sağlar.
                        let targetIndex = -1;
                        if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
                            targetIndex = currentIndex - 1;
                        } else if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
                            targetIndex = currentIndex + 1;
                        }

                        if (targetIndex >= 0 && targetIndex < activeCells.length) {
                            nextCell = activeCells[targetIndex];
                        } else {
                            nextCell = null; // Geçersiz hedef
                        }
                    }


                    if (nextCell && !nextCell.classList.contains('black')) {
                        const nextInput = nextCell.querySelector('input');
                        if (nextInput) {
                            nextInput.focus();
                        }
                    }
                }
            }
        });

        // Giriş Modalı fonksiyonları
        function showIntroModal() {
            introModal.classList.remove('hidden');
        }

        function hideIntroModal() {
            introModal.classList.add('hidden');
            startTimer(); // Modal kapatıldığında zamanlayıcıyı başlat
        }

        // Başarı Modalı fonksiyonları
        function showSuccessModal() {
            finalTimeDisplay.textContent = timerDisplay.textContent; // Bitirme süresini göster
            successModal.classList.remove('hidden');
            startConfetti(); // Konfeti efektini doğrudan burada başlat
        }

        function hideSuccessModal() {
            successModal.classList.add('hidden');
            stopSuccessSound(); // Modalı kapatırken müziği durdur
        }

        // Başarı müziği fonksiyonları
        function playSuccessSound() {
            if (successSound) {
                successSound.currentTime = 0; // Başa sar
                successSound.play().catch(e => console.error("Müzik çalınamadı:", e));
            }
        }

        function stopSuccessSound() {
            if (successSound) {
                successSound.pause();
                successSound.currentTime = 0;
            }
        }


        // Uygulama başlatıldığında
        document.addEventListener('DOMContentLoaded', () => {
            createGrid();
            populateWords();
            listQuestions();
            updateTimerDisplay(); // Zamanlayıcıyı başlangıçta 00:00 olarak ayarla

            // SCORM: Initialize LMS
            if (window.API && typeof window.API.LMSInitialize === 'function') {
                window.API.LMSInitialize('');
                console.log("SCORM Initialized: " + window.API.LMSGetValue('cmi.core.lesson_status'));
            } else {
                console.warn("SCORM API not found on window.API. Running in standalone mode.");
            }

            // Buton olay dinleyicileri
            resetButton.addEventListener('click', resetPuzzle);
            showAnswersButton.addEventListener('click', showAnswers);
            closeModalButton.addEventListener('click', hideIntroModal); // Giriş modalını kapatma
            howToPlayButton.addEventListener('click', showIntroModal); // Nasıl oynanır modalını gösterme
            playAgainButton.addEventListener('click', resetPuzzle); // Başarı modalındaki tekrar oyna butonu

            showIntroModal(); // Sayfa yüklendiğinde giriş modalını göster
        });

        // ----- Konfeti Efekti (Başarıda) -----
        function startConfetti() {
            const canvas = document.getElementById('confetti-canvas');
            if (!canvas) return;
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas.style.display = "block";
            const ctx = canvas.getContext("2d");
            const confettiCount = 120;
            const confettiColors = ["#38bdf8", "#fbbf24", "#22d3ee", "#f59e42", "#0284c7", "#10b981", "#eab308"];
            const confetti = [];
            for (let i = 0; i < confettiCount; i++) {
                confetti.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * -canvas.height,
                    r: Math.random() * 7 + 4,
                    d: Math.random() * confettiCount,
                    color: confettiColors[Math.floor(Math.random() * confettiColors.length)],
                    tilt: Math.floor(Math.random() * 8) - 4,
                    tiltAngleIncremental: (Math.random() * 0.07) + .05,
                    tiltAngle: 0
                });
            }
            let angle = 0;
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                angle += 0.01;
                for (let i = 0; i < confettiCount; i++) {
                    let c = confetti[i];
                    c.tiltAngle += c.tiltAngleIncremental;
                    c.y += (Math.cos(angle + c.d) + 3 + c.r / 2) / 2.2;
                    c.x += Math.sin(angle);
                    c.tilt = Math.sin(c.tiltAngle - (i % 2)) * 15;
                    ctx.beginPath();
                    ctx.lineWidth = c.r;
                    ctx.strokeStyle = c.color;
                    ctx.moveTo(c.x + c.tilt + c.r, c.y);
                    ctx.lineTo(c.x + c.tilt, c.y + c.tilt + c.r * 1.5);
                    ctx.stroke();
                }
            }
            function animate() {
                draw();
                for (let i = 0; i < confettiCount; i++) {
                    let c = confetti[i];
                    if (c.y > canvas.height) {
                        c.x = Math.random() * canvas.width;
                        c.y = -10;
                    }
                }
                requestAnimationFrame(animate);
            }
            animate();
            setTimeout(() => {
                canvas.style.display = "none";
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }, 2800);
        }
    </script>
</body>
</html>

<!--


Harika\! Bulmacanın son halini beğenmenize sevindim. Soru ve cevapları kolayca değiştirebilmeniz için, kodun içinde bulunan `crosswordData` adındaki JavaScript nesnesini nasıl düzenlemeniz gerektiğini açıklayacağım.

Bu nesne, bulmacanın tüm kelimelerini, ipuçlarını, konumlarını ve yönlerini içerir. Sadece bu kısmı değiştirerek bulmacanın içeriğini tamamen güncelleyebilirsiniz.

### Nasıl Bir Prompt Vermelisiniz?

Yeni soru ve cevapları değiştirmek istediğinizde, bana doğrudan `crosswordData` nesnesinin güncellenmiş halini veya sadece değiştirmek istediğiniz kelimelerin listesini verebilirsiniz. En kolayı, tüm `crosswordData.words` dizisini yeni verilerle sağlamanızdır.

**Örnek bir prompt şöyle olabilir:**

"Bulmacadaki soru ve cevapları aşağıdaki gibi güncellemek istiyorum. Sadece `crosswordData.words` kısmını değiştirir misin?"

Ardından, aşağıdaki gibi bir yapı ekleyebilirsiniz:

```javascript
const crosswordData = {
    gridSize: 12, // Izgara boyutu (değişmezse aynı kalır)
    words: [
        {
            word: "YENİKELİME1",
            clue: "Yeni kelime 1'in ipucu.",
            start_x: 0,
            start_y: 0,
            direction: "across",
            number: 1
        },
        {
            word: "YENİKELİME2",
            clue: "Yeni kelime 2'nin ipucu.",
            start_x: 0,
            start_y: 6,
            direction: "down",
            number: 2
        },
        // Diğer kelimeler buraya eklenecek
    ],
    blackCells: [] // Bu kısım otomatik hesaplandığı için değiştirmeyin
};
```
 ### `crosswordData.words` Yapısının Açıklaması:

`words` dizisi, her biri bir kelimeyi temsil eden JavaScript nesnelerinden oluşur. Her nesne şu özelliklere sahiptir:

  * **`word` (String):** Bulmacaya yerleştirmek istediğiniz kelime. **Büyük harflerle yazılmalıdır.** Türkçe karakterlere (Ğ, Ü, Ş, İ, Ö, Ç) dikkat edin.
  * **`clue` (String):** Kelimenin ipucu veya sorusu.
  * **`start_x` (Number):** Kelimenin başlangıç noktasının satır numarası (0'dan başlar).
  * **`start_y` (Number):** Kelimenin başlangıç noktasının sütun numarası (0'dan başlar).
  * **`direction` (String):** Kelimenin yönü. İki değeri olabilir:
      * `"across"` (Yatay)
      * `"down"` (Dikey)
  * **`number` (Number):** Soru numarası. Bu numara hem ızgarada hem de soru listelerinde görünür. Benzersiz olmalı ve genellikle kelimenin başlangıç noktasındaki ilk kelimeye göre sıralanır.

**Önemli Notlar:**

  * **`gridSize`:** Bu, bulmacanın genel boyutunu (örneğin 12x12) belirler. Kelimelerinizin bu boyut içinde kaldığından emin olun. Genellikle bu değeri değiştirmenize gerek kalmaz.
  * **`blackCells`:** Bu dizi, kod tarafından otomatik olarak kelimelerin yerleşimine göre hesaplanır. Bu yüzden bu kısmı değiştirmenize gerek yoktur.
  * **Kesişimler:** Kelimelerinizin birbiriyle doğru harflerde kesiştiğinden emin olmak size aittir. Eğer kelimeler kesişmiyorsa veya yanlış harflerde kesişiyorsa, bulmaca mantıksal olarak doğru çalışmayacaktır.
  * **Türkçe Karakterler:** Kodunuz Türkçe karakterleri büyük harfe çevirirken `toLocaleUpperCase('tr-TR')` kullandığı için, kelimeleri büyük harfle yazarken Türkçe karakterlere dikkat etmeniz önemlidir (örn. `İ` yerine `I`, `Ş` yerine `S` gibi hatalar yapmamaya özen gösterin).

Bu bilgilerle, bulmacanın içeriğini istediğiniz zaman kolayca güncelleyebilirsiniz. Yeni bir güncelleme istediğinizde bana bu yapıya uygun bir prompt vermeniz yeterli olacaktır.-->

